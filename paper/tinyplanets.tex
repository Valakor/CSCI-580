\documentclass[a4paper,twoside]{article}

\usepackage{epsfig}
\usepackage{subfigure}
\usepackage{calc}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{multicol}
\usepackage{pslatex}
\usepackage{apalike}
\usepackage{graphicx}
\usepackage{algorithmic}
\usepackage{textcomp}
\usepackage{SCITEPRESS}     % Please add other packages that you may need BEFORE the SCITEPRESS.sty package.

\subfigtopskip=0pt
\subfigcapskip=0pt
\subfigbottomskip=0pt

\begin{document}

\title{Tiny Planets}

\author{\authorname{Sharzard Gustafson, Matthew Pohlmann, Ricardo Sisnett}
\affiliation{University of Southern California, Los Angeles, USA.}
\email{\{sagustaf, pohlmann, sisnetth\}@usc.edu}
}

\keywords{Procedural Generation, Graphics, Perlin Noise}

\abstract{ In this paper we present a method of procedurally generating stylized planetary models with geography by combining multi-fractal Perlin noise and recursive icospheres. ... placement of  trees and ..., also procedurally modeled, ... A material system was added to visualize the results in the graphics engine... }

\onecolumn \maketitle \normalsize \vfill

\section{\uppercase{Introduction}}
\label{sec:introduction}
\noindent In this work we present the results of implementing a series of techniques in a bare bones real-time graphics engine, extending its core by adding a materials system and creating an application that utilizes procedural modeling techniques to create planetoids with natural looking geographical features. The graphics engine is built using the Simple DirectMedia Layer (SDL), a cross-platform solution for access to low-level peripherals and graphics hardware, and the openGL Extension Wrangler library (GLEW).

\section{\uppercase{Environment}}
\label{sec:env}

\subsection{Material System}
\label{sec:mat_sys}
\noindent A material system is a framework that builds on top of and abstracts the functionality and bindings of basic vertex and pixel/fragment shaders, and is commonly used in real-time graphics applications. Materials combine a vertex and fragment shader in order to re-use common shading functionality amongst multiple meshes, and provide access to shader parameters (like emissive and diffuse colors, specular power, textures, etc.) in order to customize the appearance of different surfaces; the result is that only these parameters need to be changed to represent a multitude of surfaces rather than writing and loading shader programs for each surface. An added benefit is that it becomes possible to render all meshes with common materials without changing the shader program on the GPU by simply modifying the current shader program's inputs, improving performance. Our material system implements basic Phong shading in a single vertex and fragment shader pair, and allows customization of ambient, emissive, diffuse, and specular colors, specular power, and a single texture. The system also adopts the concept of material instances in order to allow different meshes using the same material to modify parameters without affecting each other. Figure \ref{fig_ms} is a visual representation of the system we have designed and implemented for the project. The quicker iteration time provided by the material system in customizing the different meshes in the application allowed us to focus on achieving the stylized look of our original goal.

\begin{figure}
\caption{Technical diagram of our simple material system}
\label{fig_ms}
\end{figure}

\section{\uppercase{IcoSpheres}}
\label{sec:icosphere}
\noindent An icosphere is one of two of the most common ways of rendering spheres in computer graphics applications, the other being the UV sphere. An icosphere starts by taking a 20 sided polyhedron (icosahedron)  and recursively subdividing the faces to add detail. This method of generation makes the sphere's vertexes to be evenly distributed along the surface, which is a desirable trait for our use case since it lends itself better for deformation than UV spheres [REF]. Figure \ref{fig_isa} illustrates the basic idea behind this algorithm. The number of iterations can be changed to produce more or less detailed icospheres for planetary generation. In the general algorithm, generated vertices are cached in order to avoid duplicates, reduce generation time, and allow for vertex indexing on the GPU. Furthermore, normals are trivial to produce: because we generate a unit sphere, normals are vertices have the same x,y,z components of the vertices themselves. This method - when combined with Phong shading - produces incredibly smooth-shaded spheres after only a few iterations; however, our stylistic goal involves flat shading, so we modified the algorithm to duplicate vertices and calculate surface normals per-triangle. Figure \ref{fig_isn} shows the difference in the two techniques. Interestingly, the iterative nature of generating an icosphere lends itself well to Level of Detail (LOD) systems, where lower iteration counts can be used for distant icospheres, though this concept was not explored in our project.

\begin{figure}
\caption{Representation of the icosphere subdivision algorithm}
\label{fig_isa}
\end{figure}

\begin{figure}
\caption{Left, the unmodified algorithm after 2 iterations that produces indexed meshes and interpolates vertex normals. Right, our modified algorithm that produces surface normals.}
\label{fig_isn}
\end{figure}

\section{\uppercase{Perlin Noise}}
\label{sec:pnoise}
\noindent Ken Perlin's algorithm for creating pseudo-random noise is a staple in any application trying to replicate natural occurring patterns. The algorithm is fairly simple and consists of three steps: defining an n-dimensional grid, computing the dot value of distance-gradient vectors and interpolating this values.

\begin{figure}
\caption{Textured generated by our implementation of the Perlin Noise function}
\label{fig_pn}
\end{figure}

\subsection{Multi Fractal Perlin Noise}
\label{sec:mfpnois}
Classical Perlin noise is homogeneous and isotropic, this plays against the rationale to use Perlin noise: creating natural occurring patterns.  As defined in [REF] a \textit{multifractal} is a heterogeneous fractal, this is achieved by parameterizing the dimension of the fractal function with another attribute, such as the height value of the terrain, this makes it so values closer to 0 (sea level) are smoothed out, whereas high values higher octaves have a bigger effect causing jags. The instance of the algorithm implemented for this work is described in Figure \ref{fig_mf}.

\begin{figure}
\caption{Multifractal algorithm}
\label{fig_mf}
\end{figure}

\section{\uppercase{Terrain Generation}}
\label{sec:tgeneration}

\noindent Using an instance of the multi-fractal Perlin noise, we deform vertexes as they are being created by the icosphere algorithm to create geographic-looking features. We use a \textit{ridged} version of the algorithm to produce more interesting patterns as described in [REF].

The deformation is the result of displacing the vertex by a value up to a maximum deformation in the direction of the vertex normal vector, which could be interpreted as 'up' in the terrains frame of reference, thus creating a relief.

Planetary terrain is colored per-vertex using a weighted color look-up table where the index is calculated using the vertex's 'altitude' (simply the magnitude of the vertex's position). The vertex colors are interpolated by the GPU and then applied per-pixel rather than using a texture.

\begin{figure}
\caption{Terrain deformation algorithm illustrated}
\label{fig_tda}
\end{figure}

\begin{figure}
\caption{Planets generated by different levels of recursion on the icospheres}
\label{fig_iterations}
\end{figure}

\section{\uppercase{Results}}
\label{sec:results}

\vfill
\end{document}

